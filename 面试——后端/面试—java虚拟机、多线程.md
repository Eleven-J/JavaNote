

- 单例模式：

- CAS

    > - CAS思想的核心源码：
    >
    >   ![image-20210620115443275](/Users/jackiez/学海/Java开发笔记/picture/image-20210620115443275-4161286.png)
    >
    > - **Note: **“比较+更新”整体是一个原子操作，即compareAndSwapInt()不能被打断（Unsafe特性决定的）

- concurrent包的实现示意图：

  ![image-20210619223459229](/Users/jackiez/学海/Java开发笔记/picture/image-20210619223459229-4113301.png)
  
- 线程安全

  > - 不可变
  > - 互斥同步（阻塞同步）
  > - 非阻塞同步

- synchronized 和 lock(ReentrantLock)的区别

  ![image-20210620165220824](/Users/jackiez/学海/Java开发笔记/picture/image-20210620165220824-4179145.png)
  
- 锁的使用和升级过程

  <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210620171520355.png" alt="image-20210620171520355" style="zoom:50%;" />
  
- 无同步方案

  > - 栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
  > -  线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题，可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽 量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线 程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地 存储来解决线程安全问题。
  > - 可重入代码（纯代码）：可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

- 锁优化（ JVM 对 synchronized 的优化）

  > - 自旋锁
  > - 锁消除
  > - 锁粗化
  > - 轻量级锁
  > - 偏向锁

- 多线程开发经验

  > - 给线程起个有意义的名字，这样可以方便找 Bug。
  > -  缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 
  > - 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些 同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流;其次，这些同步类是由最好的企业编写和 维护，在后续的 JDK 中还会不断优化和完善。
  > -  使用 BlockingQueue 实现生产者消费者问题。
  > -  多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 
  > - 使用本地变量和不可变类来保证线程安全。 
  > - 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任 务。

- 如何创建线程？

  > 1. 继承Thread类实现，单继承
  > 2. 实现Runnable接口，重写run()方法，可以避免单继承局限 
  > 3. 重写Callable接口实现多线程
  > 4. 通过线程池启动多线程
  
- 线程池是什么？线程池参数
