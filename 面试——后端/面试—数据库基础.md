B+ Tree

> - 一棵m阶的B-Tree有如下特性:
>
>   > 1. 每个节点最多有m个孩子。 
>   > 2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
>   > 3. 若根节点不是叶子节点，则至少有2个孩子 
>   > 4. 所有叶子节点都在同一层，且不包含其它关键字信息 
>   > 5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
>   > 6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
>   > 7. ki(i=1,…n)为关键字，且关键字升序排序。 
>   > 8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
>
> - B+ Tree 和B Tree的区别：
>
>   > 1. 非叶子结点的子树指针与关键字个数相同；
>   > 2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）
>   > 3. 为所有叶子结点增加一个链指针。图中Q是通过指针连在一起的。
>   > 4. 所有关键字都在叶子结点出现。（5 8 9 10 15 18 20 26 ...等等）叶子结点相当于是存储（关键字）数据的数据层；
>   > 5. B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中）
>   > 6. 所有的非终端结点可以看成是索引部分，结点中的关键字是有其孩子指向的子树中最大（或最小）关键字。`比如第二层5 它的子树为5 8 9` (而B 树的非终节点也包含需要查找的有效信息)

- Redis

  > - Redis的淘汰机制以及过期策略
  >
  >   > - 过期策略：
  >   >
  >   >   ​	Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间(整个散列表)，而不能为键里面的单个元素设置过期时间。
  >   >
  >   >   > - 定时策略：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。
  >   >   > - 惰性策略：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  >   >   > - 定期策略：每隔一段时间对设置了缓存时间的key进行检测，如果key已经失效，则从内存中删除，如果未失效，则不作任何处理。
  >   >
  >   > - 淘汰机制：
  >   >
  >   >   ​	可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
  >   >
  >   >   > - volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  >   >   > - volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  >   >   > - volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
  >   >   > - allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰
  >   >   > - allkeys-random 从所有数据集中任意选择数据进行淘汰
  >   >   > - noeviction 禁止驱逐数据
  >
  > - 穿透、击穿、雪崩
  >
  >   > - Redis如何防止雪崩？
  >   >
  >   >   1. 什么是Redis缓存雪崩：
  >   >
  >   >   ​    Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是Redis缓存雪崩。缓存雪崩会造成数据库直接崩溃，从而导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存雪崩：
  >   >
  >   >   （1）在缓存的时候给时间加上一个随机值，设置不同的缓存过期时间，减少缓存在同一时间过期的概率。
  >   >
  >   >   （2）或者设置缓存永不过期，数据有更新再主动更新。
  >   >
  >   > - Redis如何防止穿透？
  >   >
  >   >   1. 什么是Redis缓存穿透：
  >   >
  >   >   在数据库中，正常的数据库表ID都是从1开始的（正数），但是可能有黑客想要进行破坏，所以每次发送的请求ID值都是负数。而Redis缓存中并没有ID为负数的键，导致Redis缓存失效，所有请求都去请求数据库了，而数据库也没有这个负的ID值，所以每次都是返回空，导致Redis也不会记录。所以这个不存在的数据每次请求都能够越过Redis直接请求数据库，使得Redis缓存失去了意义。这就是缓存穿透，如果大量的请求数据在缓存中不命中，导致请求直接走数据库，就有可能导致数据库崩溃，导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存穿透：
  >   >
  >   >   (1)由于请求的参数是不合法的（每次都请求不存在的参数），所以我们可以使用布隆过滤器（BloomFilter）或者压缩filter提前拦截，不合法的请求就不能请求到数据库层。
  >   >
  >   >   (2)如果通过某一个key去查询数据，而对应的数据库中不存在该数据，则可以将此key对应的value设置为一个默认的值，比如说null，并设置一个缓存的失效时间，这样，在缓存失效之前，所有的这个key的请求都会被Redis缓存挡住了。后面如果此key对应的数据在数据库中存在时，缓存失效之后，再通过此key再去访问数据，就能拿到新的value了。
  >   >
  >   > - Redis如何防止击穿？
  >   >
  >   >   1. 什么是Redis缓存击穿（热点key）：
  >   >
  >   >   缓存中的某一个key（比如说一个促销商品），在某个时间点过期的时候，刚好在这个时间点有大量的这个key的请求发送过来，这时就会有大量的请求直接访问数据库，可能会把数据库搞崩溃，从而导致系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存击穿：
  >   >
  >   >   （1）在对数据库查询的时候使用互斥锁，如果缓存过期了，在大量的请求中就只能有一个线程能够拿到查询数据库的锁，而其他的请求只能进入等待状态，等该线程进行完查询操作后，把拿到的数据写入Redis缓存中，重新设置缓存过期时间，这样其他的请求又会请求到Redis缓存，避免了数据库的崩溃。
  >   >
  >   >   （2）根据情况可以设置热点key永不过期,配合定时任务更新cache,或者数据有更新再主动更新。
  >
  > - redis基本数据类型
  >
  >   > - String
  >   >
  >   >   ![image-20210713165433052](/Users/jackiez/学海/Java开发笔记/picture/image-20210713165433052-6166478.png)
  >   >
  >   > - HashMap
  >   >
  >   >   应用：简单版购物车或订单
  >   >
  >   > - List
  >   >
  >   >   应用：微信文章订阅公众号
  >   >
  >   > - Set
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210713170705479.png" alt="image-20210713170705479" style="zoom:50%;" />
  >   >
  >   > - zset
  >   >
  >   >   ![image-20210713171158045](/Users/jackiez/学海/Java开发笔记/picture/image-20210713171158045-6167520.png)
  >
  > - redis集群部署情况？
  >
  > - 简述kafka，如何实现生产者和消费者
  >
  > - redis会出现因为多线程而造成数据读写错误吗
  >
  > - redis之前是使用了但线程，但是redis6.0采用了多线程，你觉得为什么要这么改
  >
  >   > 为了应对越来越复杂的qps要求，redis做出了让步，但是redis6.0默认是禁止多线程的，可以在配置中打开，选择权交给了用户
  >
  > - 

- 数据库索引的选取

- 回表问题