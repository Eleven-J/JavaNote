- JDK1.8相比于JDK1.7多了哪些功能，做了哪些优化？

  > - 在**JDK1.8** hotspot移除了**永久代**用**元空间(****Metaspace)**
  > - hashmap，CurrentHashmap

- 做个题，将一个数组建立成二叉树，再中序遍历

  ```java
  public void inOrder(TreeNode root){
    if(root == null){
      return;
    }
    inOrder(root.left);
    System.out.println(root.val);
    inOrder(root.right);
  }
  ```

- JVM运行期内存空间，每块的作用✅

  > - 线程私有，不用进行垃圾回收，线程结束即消失。
  >
  >   > - 程序计数器：记录的是正在执行的字节码的地址
  >   > - 虚拟机栈：每个方法会创建一个栈帧来存放相应的局部变量，常量池引用等信息。从方法调用直至 执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程
  >   > - 本地方法栈：与虚拟机栈类似，只不过本地方法栈是为本地方法服务。
  >
  > - 需要进行垃圾回收
  >
  >   > - 方法区：用于存储已经被虚拟机加载的类信息、常量、静态常量、 即时编译器编译后的代码等数据。方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，移除永久代，原来永久代的数据被分到了堆和元 空间中。**元空间存储类的元信息，静态变量和常量池等放入堆中**。
  >   > - 堆：所有对象都在这里分配内存，是垃圾收集的主要区域("GC 堆")。

- 字符串常量池：**（有疑问？）**

  > - 存放位置：1.7以前在方法区，1.8在堆中。
  > - 对于直接做+运算的两个字符串（字面量）常量，并不会放入字符串常量池中，而是直接把运算后的结果放入字符串常量池中(String s = "abc"+ "def", 会直接生成“abcdef"字符串常量  而不把 "abc" "def"放进常量池) 
  > - 对于先声明的字符串字面量常量，会放入字符串常量池，但是若使用字面量的引用进行运算就不会把运算后的结果放入字符串常量池中了
  >   (String s = new String("abc") + new String("def"),在构造过程中不会生成“abcdef"字符串常量) 
  > - **常量池中同时存在字符串常量和字符串引用。**直接赋值和用字符串调用String构造函数都可能导致常量池中生成字符串常量;而intern()方法会尝试将堆中对象的引用放入常量池

- 虚拟机的类加载机制，具体步骤及对应完成的事情

  > - 加载阶段：通过类的全限定名称获取定义该类的二进制字节流，将其表示静态存储结构转换为方法区的运行时存储结构，在堆内存中生成一个Class对象，作为方法区中该类各种数据的访问入口。
  > - 验证阶段：确保Class文件的字节流中包含的信息符合java虚拟机要求。
  > - 准备阶段：为 类变量 分配内存并设置初始值。
  > - 解析阶段：将常量池的符号引用替换为直接引用
  > - 初始化阶段：该阶段才真正开始执行类中定义的java程序代码，执行类的构造器<clinit>()方法，根据程序制定的主观计划去初始化类变量和其他资源 .

- JVM的双亲委派模型

  > - 双亲委派机制就是如果一个类加载器收到了类加载请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈到无法完成这个加载请求（它的搜索范围没有找到这个类），子加载器才会尝试自己去加载。
  > - 启动类加载器（jvm的一部分）
  > - 扩展类加载器 （java.lang.ClassLoader）
  > - 应用程序类加载器（java.lang.ClassLoader）
  > - 自定义加载器

- ArrayList和Linkedlist底层

  ​	数组，双向链表

- ArrayList扩容机制

  > - Add( )方法触发自动扩容时，默认扩容为原数组列表的1.5倍。
  > - 创建Arraylist时，无参数构造方法默认容量为10（jdk源码表示：其实创建时容量为0，添加第一个元素时，容量自动默认为10）。

- HashMap扩容机制？

  > ​	初始值默认为16，装载因子为0.75，每次扩容为之前的两倍。初始容量最好是2的n次方，因为扩容的时候是开辟一块新的空间，然后将之前的copy过来，同时需要对应好hash值，这时候不会重新再算一遍hash值，而是通过二进制的特性及初始容量是2的N次方的特性，使之对应上。当然，你要是在构造函数中传入的不是2的n次方，也会自动给你转成2的n次方。

- 如何判断对象是否可被回收

  > 可达性分析，GC Roots：
  >
  > - 虚拟机栈中局部变量表中引用的对象 
  > - 本地方法栈中 JNI 中引用的对象 
  > - 方法区中类静态属性引用的对象 
  > - 方法区中的常量引用的对象

- JVM垃圾收集每种[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，实现方式，各自特点

  > - 标记-清除
  >
  >   > - 实现方式：简单的标记，然后清除掉
  >   >
  >   > - 缺点：
  >   >
  >   >   > - 标记和清除过程效率都不高;
  >   >   > - 会产生大量不连续的内存碎片，导致无法给大对象分配内存，从而又触发新的一次垃圾收集。
  >
  > - 复制
  >
  >   > - 实现方式：将内存一分为二，只用一半，垃圾收集时将还存活的对象复制到另外一半空内存空间上，然后对用了的这一半一次全部清除，这样就不存在产生大量内存碎片的问题了。
  >   > - 缺点：虽然不存在内存碎片的问题，但是代价却是巨大的，因为实际可使用内存减半了。
  >
  > - 标记-整理
  >
  >   > - 实现方式：标记阶段与标记-清除算法一样，整理阶段是不直接清除可回收对象，而是先将存活对象都向一端移动，然后再清理端边界以外的内存。
  >   > - 缺点：需要移动大量对象，处理效率比较低。
  >
  > - 分代收集
  >
  >   > - 实现方式：将堆区划分为老年代和新生代，老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。对于新生代都采取**复制算法**因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间；而由于老年代的特点是每次回收都只回收少量对象，一般使用的是**标记-整理算法（压缩法）**。
  >   > - 缺点：没啥缺点呵呵

- 垃圾回收器

  > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712160844567.png" alt="image-20210712160844567" style="zoom:50%;" />
  >
  > ![image-20210712164916098](/Users/jackiez/学海/Java开发笔记/picture/image-20210712164916098-6079758.png)
  >
  > ![image-20210712173620887](/Users/jackiez/学海/Java开发笔记/picture/image-20210712173620887-6082582.png)
  >
  > ![image-20210712163424913](/Users/jackiez/学海/Java开发笔记/picture/image-20210712163424913-6078867.png)
  >
  > ![image-20210712163747424](/Users/jackiez/学海/Java开发笔记/picture/image-20210712163747424.png)
  >
  > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712164339978.png" alt="image-20210712164339978" style="zoom:50%;" />
  >
  > ![image-20210712164607741](/Users/jackiez/学海/Java开发笔记/picture/image-20210712164607741-6079569.png)
  >
  > ![image-20210712165356205](/Users/jackiez/学海/Java开发笔记/picture/image-20210712165356205-6080039.png)
  >
  > ![image-20210712170021769](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170021769-6080423.png)
  >
  > ![image-20210712170231882](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170231882.png)
  >
  > ![image-20210712170514689](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170514689-6080716.png)
  >
  > ![image-20210712170822276](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170822276-6080904.png)
  >
  > ![image-20210712171012140](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171012140-6081014.png)
  >
  > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712171116909.png" alt="image-20210712171116909" style="zoom:50%;" />![image-20210712171415218](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171415218-6081257.png)
  >
  > ![image-20210712171652754](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171652754.png)
  >
  > ![image-20210712172026237](/Users/jackiez/学海/Java开发笔记/picture/image-20210712172026237-6081628.png)
  >
  > ![image-20210712172131647](/Users/jackiez/学海/Java开发笔记/picture/image-20210712172131647-6081693.png)

- 调用system.gc()一定会发生垃圾收集吗？为什么？

  ​	不一定会马上发生，其实当我们直接调用`System.gc()`只会把这次gc请求记录下来，等到`runFinalization=true`的时候才会先去执行GC

- 说一下对于树的理解（二叉树，平衡树，红黑树，B+树，二叉查找树）

- 说一下你理解的几种设计模式

  > - 单例模式：确保一个类只有一个实例，并提供该实例的全局访问点。
  >
  >   - 懒汉式-线程不安全（延迟实例化，你不用到我，我就不实例化）
  >
  >   ```java
  >    public class Singleton {
  >       private static Singleton uniqueInstance;
  >       private Singleton() {
  >       }
  >       public static Singleton getUniqueInstance() {
  >           if (uniqueInstance == null) {
  >               uniqueInstance = new Singleton();
  >           }
  >           return uniqueInstance;
  >       }
  >   }
  >   ```
  >
  >   - 饿汉式-线程安全（不管你用不用到我，我事先都实例化）
  >
  >     ```java
  >     private static Singleton uniqueInstance = new Singleton();
  >     ```
  >
  >   - 懒汉式-线程安全
  >
  >     ​	只需要对 getUniqueInstance() 方法加锁（同步），那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。
  >      	但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。
  >
  >   - 双重校验锁-线程安全
  >
  >     ```java
  >     public class Singleton {
  >       //uniqueInstance 采用 volatile 关键字修饰也是很有必要,禁止指令重排
  >         private volatile static Singleton uniqueInstance;
  >         private Singleton() {
  >         }
  >         public static Singleton getUniqueInstance() {
  >             if (uniqueInstance == null) {
  >                 synchronized (Singleton.class) {
  >                     if (uniqueInstance == null) {
  >                         uniqueInstance = new Singleton();
  >                     }
  >     } }
  >             return uniqueInstance;
  >         }
  >     }
  >     ```
  >
  >   - 静态内部类实现-线程安全
  >
  >     ​	当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。
  >
  >     ​	这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。
  >
  >     ```java
  >     public class Singleton {
  >         private Singleton() {
  >         }
  >         private static class SingletonHolder {
  >             private static final Singleton INSTANCE = new Singleton();
  >     		}
  >         public static Singleton getUniqueInstance() {
  >             return SingletonHolder.INSTANCE;
  >     		} 
  >     }
  >     ```
  >
  >   - 枚举实现。。。
  >
  > - 简单工厂：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口
  >
  >   ```java
  >   public class SimpleFactory {
  >       public Product createProduct(int type) {
  >           if (type == 1) {
  >               return new ConcreteProduct1();
  >           } else if (type == 2) {
  >               return new ConcreteProduct2();
  >           }
  >           return new ConcreteProduct();
  >       }
  >   }
  >   public class Client {
  >       public static void main(String[] args) {
  >           SimpleFactory simpleFactory = new SimpleFactory();
  >           Product product = simpleFactory.createProduct(1);
  >           // do something with the product
  >   } }
  >   ```
  >
  > - 工厂方法：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
  >
  >   ```java
  >    public abstract class Factory {
  >       abstract public Product factoryMethod();
  >       public void doSomething() {
  >           Product product = factoryMethod();
  >           // do something with the product
  >       }
  >   }
  >    public class ConcreteFactory extends Factory {
  >       public Product factoryMethod() {
  >           return new ConcreteProduct();
  >       }
  >   }
  >    public class ConcreteFactory1 extends Factory {
  >       public Product factoryMethod() {
  >           return new ConcreteProduct1();
  >       }
  >   }
  >   public class ConcreteFactory2 extends Factory {
  >       public Product factoryMethod() {
  >           return new ConcreteProduct2();
  >       }
  >   }
  >   ```
  >
  > - 抽象工厂：提供一个接口，用于创建相关的对象家族 。
  >
  > - 生成器：封装一个对象的构造过程，并允许按步骤构造。
  >
  > - 原型模式：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。

- MYSQL的A C I D怎样实现的？

  > - 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
  >
  >   > 如何保证？利用回滚日志Undo
  >
  > - 一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
  >
  >   > 如何保证？通过原子性，隔离性，持久性来保证一致性
  >
  > - 隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
  >
  >   > 如何保证？锁和MVCC机制
  >
  > - 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  >
  >   > 如何保证？利用redo日志

- MYSQL的事务隔离机制/级别（4种隔离级别）

  > - 未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。
  > - 提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
  > - 可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。
  > - 可串行化：强制事务串行执行。（需要加锁实现，而其它隔离级别通常不需要）

- MVCC

  > - 定义：多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
  >
  > - 原理：利用版本号来实现。
  >
  >   ```java
  >   /*
  >     系统版本号:是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
  >     事务版本号:事务开始时的系统版本号。
  >   */
  >   MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:
  >   	1.创建版本号:指示创建或更新一个数据行的快照时的系统版本号;当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号,理解这点很关键。
  >   	2.删除版本号:指删除或更新一个数据行的快照时的系统版本号。如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。
  >     MVCC 使用到的快照存储在 Undo日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。
  >   ```

- Redis的淘汰机制以及过期策略说一下

  > - 过期策略：
  >
  >   ​	Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间(整个散列表)，而不能为键里面的单个元素设置过期时间。
  >
  >   > - 定时策略：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。
  >   > - 惰性策略：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  >   > - 定期策略：每隔一段时间对设置了缓存时间的key进行检测，如果key已经失效，则从内存中删除，如果未失效，则不作任何处理。
  >
  > - 淘汰机制：
  >
  >   ​	可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
  >
  >   > - volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  >   > - volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  >   > - volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
  >   > - allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰
  >   > - allkeys-random 从所有数据集中任意选择数据进行淘汰
  >   > - noeviction 禁止驱逐数据

- TCP 三次握手，每一次握手是为了做什么，为什么需要第三次握手

- OSI 七层模型

  ​	应用层，表示层，会话层，运输层，网络层，数据链路层，物理层

- HTTP 和 HTTPS 的区别

  > - https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
  >
  > - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
  >
  > - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
  >
  > - http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
  >
  > - http的缺点
  >
  >   > - 通信使用明文(不加密)，内容可能被窃听
  >   >
  >   >   > 加密
  >   >
  >   > - 不验证通信方的身份，因此有可能遭遇伪装（假的server或client）
  >   >
  >   >   > 证书 （支持双向验证，但通常只验证服务端.）
  >   >   > SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份
  >   >
  >   > - 无法证明报文的完整性，所以有可能已遭篡改
  >   >
  >   >   > 基于散列值校验（MD5 / SHA-1）等等的完整性校验方案
  >
  > -   Https解决了上述http的缺点，其认证流程和加密流程如下图（HTTPS=HTTP+加密+认证+完整性保护）：
  >
  >     ![这里写图片描述](/Users/jackiez/学海/Java开发笔记/picture/70.png)

- JWT包括那几个部分

  > ```json
  > eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
  > ```
  >
  > - 头部（header）：承载两部分信息
  >
  >   > - 声明类型，这里是jwt
  >   > - 声明加密的算法 通常直接使用 HMAC SHA256（默认）
  >   >
  >   > ```json
  >   > {
  >   >   'typ': 'JWT',
  >   >   'alg': 'HS256'
  >   > }
  >   > ```
  >   >
  >   > 然后将头部进行base64编码（没有加密）,构成了第一部分eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
  >
  > - 载荷（payload）：载荷就是存放有效信息的地方
  >
  >   > **标准中注册的声明** 
  >   >
  >   > - iss (issuer)：签发人
  >   > - exp (expiration time)：过期时间
  >   > - sub (subject)：主题
  >   > - aud (audience)：受众
  >   > - nbf (Not Before)：生效时间
  >   > - iat (Issued At)：签发时间
  >   > - jti (JWT ID)：编号
  >   >
  >   > **私有的声明** ：
  >   > 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，意味着该部分信息可以归类为明文信息。
  >   >
  >   > ```json
  >   > {
  >   > "sub": "1234567890",
  >   > "name": "John Doe",
  >   > "admin": true
  >   > }
  >   > ```
  >   >
  >   > 然后将其进行base64编码，得到Jwt的第二部分。eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
  >
  > - 签证（signature）
  >
  >   ​	这个部分需要base64编码后的header和base64编码后的payload使用`.`连接组成的字符串，然后通过header中声明的加密方式进行`secret`组合加密，然后就构成了jwt的第三部分。
  >
  > - 特性
  >
  >   > （1）JWT 默认是不加密（数据是明文保存的），但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
  >   >
  >   > （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。
  >   >
  >   > （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
  >   >
  >   > （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
  >   >
  >   > （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
  >   >
  >   > （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。
  >
  > - 使用方式
  >
  >   ​	客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。
  >
  >   ```json
  >   Authorization: Bearer <token>
  >   ```

- 浏览器同源策略

  > ​	同源策略限制了从同一个源**加载的脚本**(如js)与来自另一个源的资源进行交互。浏览器会对非同源请求的返回的结果进行拦截。
  >
  > ​	举个例子，浏览器打开了一个标签页，访问百度页面，百度前端服务器给浏览器返回首页的前端资源（其中包括了js代码，其实就上面所说的脚本），点击首页上的链接（假设是查询数据库操作），js就会去访问百度后端服务器去拿相应数据。此时由于前后端服务器不同ip地址和端口号，也就是说前端服务器和后端服务器对于浏览器来说是不同源的，存在跨域问题。
  >
  > ​	页面中的链接，重定向以及表单提交是不会受到同源策略限制的。

- 跨域问题

  > 

- 数据库三大范式

  > - 第一范式:  确保每列保持原子性
  >
  >   ​	比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式
  >
  > - 第二范式:  确保表中的每列都和主键相关(拒绝联合主键)
  >
  >   ​	比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了
  >
  > - 第三范式：确保每列都和主键列直接相关,而不是间接相关（数据不能存在传递关系）
  >
  >   ​	比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。



- 排序问题：

  > - 为什么用快排而不用堆排序
  >
  >   > 1. 堆排序数据访问的方式没有快速排序友好
  >   > 2. 于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序

- 多线程

  > - 多线程的创建方式
  >
  >   > - 继承Thread类
  >   > - 实现Runnable接口
  >   > - 实现Callable接口（创建的线程带返回值）

- 阻塞队列

  <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210711192529708.png" alt="image-20210711192529708" style="zoom:50%;" />

  > - BlockingQueue隶属于Collection-Queue接口下
  >
  >   > - ArrayBlockingQueue:由数组结构组成的有界阻塞队列
  >   > - LinkedBlockingQueue:由链表结构组成的无界阻塞队列
  >   > - SynchronousQueue：不存储元素的阻塞队列，即单个元素的阻塞队列（生产一个，消费一个）

- 使用线程池的好处，如何创建线程池

  > - 线程池的底层：ThreadPoolExecutor类 
  >
  >   > ![image-20210711221417579](/Users/jackiez/学海/Java开发笔记/picture/image-20210711221417579.png)
  >
  > - 线程池的七大参数（底层原理就按照参数来介绍就ok了）
  >
  >   > ![image-20210711222046758](/Users/jackiez/学海/Java开发笔记/picture/image-20210711222046758-6013249.png)
  >   >
  >   > jdk内置的四种策略
  >   >
  >   > ![image-20210711224518472](/Users/jackiez/学海/Java开发笔记/picture/image-20210711224518472.png)
  >
  > - Executors工具类自带的线程池创建方法（一般不用，都是根据业务实际情况自定义线程池）
  >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210711221143161.png" alt="image-20210711221143161" style="zoom:50%;" />
  >
  > - 好处：
  >
  >   > - 降低拼频繁创建线程，销毁线程所带来的性能消耗
  >   > - 提高响应时间（业务不用等系统来给它创建线程）
  >   > - 便于统一管理线程的复用
  >
  > - 合理配置线程池你是如何考虑的？
  >
  >   > - cpu密集型：阻塞比较少，cup资源大量的花费在运算上，此时增加过多的线程数并不能提高整体性能，参考：cpu核数+1
  >   > - io密集型：该任务有大量的io，即存在大量的阻塞，此时线程太少的话，阻塞回引起大量的cpu运算资源的浪费（等待是cpu空转），参考：cpu核数/（1-阻塞系数）
  >
  > - 死锁
  >
  >   > -  定义：两个或两个以上的线程因争夺资源而造成的一种互相等待的现象
  >   >
  >   > - 主要原因
  >   >
  >   >   > - 系统资源不足
  >   >   > - 资源分配不当
  >   >   > - 进程运行推进的顺序不对

- AQS

  > - 可重入锁
  >
  > - LockSupport：拥有线程等待/唤醒机制（wait/notify）加强版，使用park()、unpack()
  >
  >   > 等待唤醒的三种机制
  >   >
  >   > ![image-20210712235714026](/Users/jackiez/学海/Java开发笔记/picture/image-20210712235714026-6105435.png)
  >   >
  >   > 底层：permit许可证
  >   
  > - AQS定义：
  >
  >   ![image-20210713131403649](/Users/jackiez/学海/Java开发笔记/picture/image-20210713131403649.png)
  >
  >   ![image-20210713132033913](/Users/jackiez/学海/Java开发笔记/picture/image-20210713132033913.png)
  >
  >   ![image-20210713132219636](/Users/jackiez/学海/Java开发笔记/picture/image-20210713132219636-6153741.png)
  >
  >   ![image-20210713133529914](/Users/jackiez/学海/Java开发笔记/picture/image-20210713133529914-6154533.png)
  >
  >   ![image-20210713142638118](/Users/jackiez/学海/Java开发笔记/picture/image-20210713142638118-6157599.png)
  >
  >   ![image-20210713140434333](/Users/jackiez/学海/Java开发笔记/picture/image-20210713140434333-6156276.png)
  >
  >   ![image-20210713140313746](/Users/jackiez/学海/Java开发笔记/picture/image-20210713140313746-6156195.png)
  >
  >   入队以后先自旋来尝试看是否能抢到锁（非公平锁），若果自旋一会儿还是没抢到，就放弃自旋，转而被LockSupport阻塞。
  >
  >   ![image-20210713140557229](/Users/jackiez/学海/Java开发笔记/picture/image-20210713140557229-6156358.png)
  >
  >   

- JUC

  > - 我们知道ArrayList是线程不安全的，JUC是如何处理的？
  >
  > - concurrent包的实现
  >       Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：
  >
  >   首先，声明共享变量为volatile；
  >   然后，使用CAS的原子条件更新来实现线程之间的同步；
  >   同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。
  >   AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：
  >
  >
  >   ![img](/Users/jackiez/学海/Java开发笔记/picture/format,png.png)

- 索引的作用

- redis

  


